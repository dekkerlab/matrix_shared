resolutions = [25000,50000]

wildcard_constraints:
    res="\d+"

##############
# fix that add a dict for pair dict ...

cooler_path_dict = {k.rstrip('.no_filter.1000.mcool'):v for k,v in zip(config["samples"],config["cooler_path"])}
pairs_path_dict = {k.rstrip('.no_filter.1000.mcool'):v for k,v in zip(config["samples"],config["pairs_path"])}


localrules: all , compute_insulation, compute_n_clean_expected, call_compartments, compute_saddle, compute_scaling

rule all:
    input:
       expand(
            ["{out_path}/compute_saddle/{hic_name}.{res}.cis.pdf",
            "{out_path}/insulation/{hic_name}.{res}.cis.bed","{{out_path}}/scaling/{{hic_name}}.scalingdata.npz"],zip,
            out_path=config["output_path"],
            # path = "/nl/umw_job_dekker/users/ba69w/HiC_Analysis/U54_deep/results/coolers_library_group/",
            hic_name = [_.rstrip('.no_filter.1000.mcool') for _ in config["samples"]],res=resolutions)

rule compute_insulation:
    input:
        lambda wc: os.path.join( cooler_path_dict[wc.hic_name], wc.hic_name+'.no_filter.1000.mcool' )
    params:
        # we have to use something like that to prevent numpy from using threaded MKL ...
        mkl_preamble = "export MKL_NUM_THREADS=1;\n echo threads MKL $MKL_NUM_THREADS;\n"
    output:
        expand("{{out_path}}/insulation/{{hic_name}}.{res}.cis.bed",res=resolutions)
    run:
        for res, out_local in zip(resolutions, output):
            print("Trying to compute insulation for {}".format(res))
            print({input})
            shell(" {params.mkl_preamble} "+
                "cooltools diamond-insulation --balance {input[0]}::/resolutions/{res} 200000 > {out_local}")

rule compute_n_clean_expected:
    input:
        lambda wc: os.path.join( cooler_path_dict[wc.hic_name], wc.hic_name+'.no_filter.1000.mcool' )
        #lambda wildcards: config["samples"][wildcards.sample]
    params:
        # we have to use something like that to prevent numpy from using threaded MKL ...
        mkl_preamble = "export MKL_NUM_THREADS=1;\n echo threads MKL $MKL_NUM_THREADS;\n"
    output:
        expand("{{out_path}}/expected/{{hic_name}}.{res}.cis.expected.tsv",res=resolutions)
    threads: 9
    run:
        for res, out_local in zip(resolutions, output):
            print("Trying to compute expected for {}".format(res))
            print({input})
            shell(" {params.mkl_preamble} "+
                "cooltools compute-expected -p {threads} --drop-diags 1 {input[0]}::/resolutions/{res} > {out_local}")

rule call_compartments:
    input:
        lambda wc: os.path.join( cooler_path_dict[wc.hic_name], wc.hic_name+'.no_filter.1000.mcool' ),
        gene_cov_file=expand("{{out_path}}/gene_cov.hg38.{res}.txt", res=resolutions)
        #lambda wildcards: config["samples"][wildcards.sample]
    params:
        # we have to use something like that to prevent numpy from using threaded MKL ...
        mkl_preamble = "export MKL_NUM_THREADS=1;\n echo threads MKL $MKL_NUM_THREADS;\n"
    output:
        expand("{{out_path}}/call_compartments/{{hic_name}}.{res}.cis.vecs.tsv",res=resolutions)
    threads: 9
    run:
        for res, out_local, gene_cov_file in zip(resolutions, output,input.gene_cov_file):
            print("Trying to compute compartments for {}".format(res))
            print({input})
            #print({out_local})
            out_local_prefix=out_local.rstrip('.cis.vecs.tsv')
            shell(" {params.mkl_preamble} "+
                "cooltools call-compartments --contact-type cis --reference-track {gene_cov_file} --bigwig -o {out_local_prefix} {input[0]}::/resolutions/{res}")

rule compute_saddle:
    input:
        cool = lambda wc: os.path.join( cooler_path_dict[wc.hic_name], wc.hic_name+'.no_filter.1000.mcool' ),
        ############## my suggestion use os.path.join instead of text formatting ...
        # lambda wc: "{}/{}.no_filter.1000.mcool".format(dict_where_keys_arehic_names_and_values_are_cool_paths[wc.hic_name],wc.hic_name)
        #
        ###############
        #cool = lambda wc: os.path.join({cool_path},{hic_name}),
        expected = expand("{{out_path}}/expected/{{hic_name}}.{res}.cis.expected.tsv",res=resolutions),
        tsv_comp = expand("{{out_path}}/call_compartments/{{hic_name}}.{res}.cis.vecs.tsv",res=resolutions)

        #lambda wildcards: config["samples"][wildcards.sample]
    params:
        # we have to use something like that to prevent numpy from using threaded MKL ...
        mkl_preamble = "export MKL_NUM_THREADS=1;\n echo threads MKL $MKL_NUM_THREADS;\n"
    output:
        expand("{{out_path}}/compute_saddle/{{hic_name}}.{res}.cis.pdf", res=resolutions)
    run:
        for res,expected,tsv_comp,out_local in zip(resolutions,input.expected,input.tsv_comp,output):
            out_local_prefix=out_local.rstrip('.cis.pdf')
            print("Trying to compute saddle for {}".format(res))
            shell(" {params.mkl_preamble} "+
                "cooltools compute-saddle --strength --vmin -1 --vmax 1 --qrange 0.02 0.98 --contact-type cis --out-prefix {out_local_prefix} --fig pdf {input.cool}::/resolutions/{res} {tsv_comp} {expected}")

rule compute_scaling:
    input:
        pairs = lambda wc: os.path.join( pairs_path_dict[wc.hic_name], wc.hic_name+'.nodups.pairs.gz' ),
        chrom_sizes = "/nl/umw_job_dekker/users/ba69w/genome/hg38.reduced.chrom.sizes"
    params:
        # we have to use something like that to prevent numpy from using threaded MKL ...
        mkl_preamble = "export MKL_NUM_THREADS=1;\n echo threads MKL $MKL_NUM_THREADS;\n"
    output:
        "{{out_path}}/scaling/{{hic_name}}.scalingdata.npz"
    threads: 8
    run:
        for pairs_file,chrom_sizes,out_local in zip(input.pairs,input.chrom_sizes,output):
            out_local_prefix=out_local.rstrip('.scalingdata.npz')
            print("Scaling in running")
            shell(" {params.mkl_preamble} "+
                "python /nl/umw_job_dekker/users/ba69w/HiC_Analysis/U54_matrix/cooler_analysis_old_mapping/scaling_script_multiprocess.py -p {thread} --dmin 1000 --dmax 200000000 -o {out_local_prefix} {pairs_file} {chrom_sizes} ")

